# redis


## redis五大数据类型 {id="redis_1"}
Redis支持五种数据类型：string（字符串），hash（哈希），list（列表），set（集合）和zset(sorted set 有序集合)。  

### 字符串
```
SET			赋值，用法：SET key value
GET			取值，用法：GET key
INCR		递增数字，仅仅对数字类型的键有用，相当于Java的i++运算，用法：INCR key
INCRBY		增加指定的数字，仅仅对数字类型的键有用，相当于Java的i+=3，用法：INCRBY key increment，意思是key自增increment，increment可以为负数，表示减少。
DECR		递减数字，仅仅对数字类型的键有用，相当于Java的i--，用法：DECR key
DECRBY		减少指定的数字，仅仅对数字类型的键有用，相当于Java的i-=3，用法：DECRBY key decrement，意思是key自减decrement，decrement可以为正数，表示减少。
INCRBYFLOAT	增加指定浮点数，仅仅对数字类型的键有用，用法：INCRBYFLOAT key increment
APPEND		向尾部追加值，相当于Java中的”hello”.append(“ world”)，用法：APPEND key value
STRLEN		获取字符串长度，用法：STRLEN key
```

### 散列（hash）
散列类型相当于Java中的HashMap，他的值是一个字典，保存很多key和value对，每对key和value的值个键都是字符串类型。换句话说，散列类型不能嵌套其他数据类型。一个散列类型键最多可以包含2的32次方-1个字段。

```
HSET		赋值，用法：HSET key field value
HMSET		一次赋值多个字段，用法：HMSET key field1 value1 [field2 values]
HGET		取值，用法：HSET key field
HMGET		一次取多个字段的值，用法：HMSET key field1 [field2]
HGETALL		一次取所有字段的值，用法：HGETALL key
HEXISTS		判断字段是否存在，用法：HEXISTS key field
HSETNX		当字段不存在时赋值，用法：HSETNX key field value
HINCRBY		增加数字，仅对数字类型的值有用，用法：HINCRBY key field increment
HDEL		删除字段，用法：HDEL key field
HKEYS		获取所有字段名，用法：HKEYS key
HVALS		获取所有字段值，用法：HVALS key
HLEN		获取字段数量，用法：HLEN key
```

### 列表（list）
1. 列表类型用于存储一个有序的字符串列表，常用的操作是向队列两端添加元素或者获得列表的某一片段。
2. 列表内部使用的是双向链表（double linked list）实现的，所以向列表两端添加元素的时间复杂度是O(1)，获取越接近列表两端的元素的速度越快。但是缺点是使用列表通过索引访问元素的效率太低（需要从端点开始遍历元素）。所以列表的使用场景一般如：朋友圈新鲜事，只关心最新的一些内容。
3. 借助列表类型，Redis还可以作为消息队列使用。

```
LPUSH		向列表左端添加元素，用法：LPUSH key value
RPUSH		向列表右端添加元素，用法：RPUSH key value
LPOP		从列表左端弹出元素，用法：LPOP key
RPOP		从列表右端弹出元素，用法：RPOP key
LLEN		获取列表中元素个数，用法：LLEN key
LRANGE		获取列表中某一片段的元素，用法：LRANGE key start stop，index从0开始，-1表示最后一个元素
LREM		删除列表中指定的值，用法：LREM key count value，删除列表中前count个值为value的元素，当count>0时从左边开始数，count<0时从右边开始数，count=0时会删除所有值为value的元素
LINDEX		获取指定索引的元素值，用法：LINDEX key index
LSET		设置指定索引的元素值，用法：LSET key index value
LTRIM		只保留列表指定片段，用法：LTRIM key start stop，包含start和stop
```

### 集合类型（set）
集合在概念在高中课本就学过，集合中每个元素都是不同的，集合中的元素个数最多为2的32次方-1个，集合中的元素是没有顺序的。
```
SADD		添加元素，用法：SADD key value1 [value2 value3 ...]
SREM		删除元素，用法：SREM key value2 [value2 value3 ...]
SMEMBERS	获得集合中所有元素，用法：SMEMBERS key
SISMEMBER	判断元素是否在集合中，用法：SISMEMBER key value
SPOP		从集合中随机弹出一个元素，用法：SPOP key
```

### 有序集合  
1. 有序集合类型与集合类型的区别就是他是有序的。
2. 有序集合是在集合的基础上为每一个元素关联一个分数，这就让有序集合不仅支持插入，删除，判断元素是否存在等操作外，还支持获取分数最高/最低的前N个元素。有序集合中的每个元素是不同的，但是分数却可以相同。
3. 有序集合使用散列表和跳跃表实现，即使读取位于中间部分的数据也很快，时间复杂度为O(log(N))，有序集合比列表更费内存。
```
ZADD		添加元素，用法：ZADD key score1 value1 [score2 value2 score3 value3 ...]
ZSCORE		获取元素的分数，用法：ZSCORE key value
ZRANGE		获取排名在某个范围的元素，用法：ZRANGE key start stop [WITHSCORE]，按照元素从小到大的顺序排序，从0开始编号，包含start和stop对应的元素，WITHSCORE选项表示是否返回元素分数
ZREVRANGE	获取排名在某个范围的元素，用法：ZREVRANGE key start stop(从大到小)
ZCARD		获取集合中元素的个数，用法：ZCARD key
ZCOUNT		获取指定分数范围内的元素个数，用法：ZCOUNT key min max，min和max包含min和max
ZREM		删除一个或多个元素，用法：ZREM key value1 [value2 ...]
ZRANK		获取正序排序的元素的排名，用法：ZRANK key value
ZREVRANK	获取逆序排序的元素的排名，用法：ZREVRANK key value
```

## redis如何持久化？ {id="redis_3"}
redis 的一大特点就是可以将数据进行持久化，在一定程度上确保了数据的安全性，但不是绝对的。首先持久化分为 rdb（快照持久化）和 aof（精细持久化）。

### 快照持久化
1. 快照持久化，是默认开启的。会自动保存数据，当启动时会在文件夹中生成dump.rdb文件，存放持久化后的数据。
2. 当然我们也可以设置持久化的频率，在 redis.conf 文件中通过save进行设置。默认有三种情况，每秒超过一万数据或每5分钟有10条数据的时候再或者每15分钟有1条记录，都会执行快照持久化。
3. 当然也可以通过 bgsave 的方法来手动进行一个快照持久化。（也可以通过ip和端口号就给别人进行手动持久化）  
4. 如果频繁的快照持久化，会降低性能和效率，但是这样也出现了一个问题，就是当一分钟内如果有一万条数据时，不会提交，但是在下一次提交之前，停电了，这样就会丢失掉这些数据。
5. 当时想到的解决方法呢就是和（AOF）精细持久化进行一个结合，达到一个秒级的持久化。
6. RDB持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘，实际操作过程是 fork 一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的文件，用二进制压缩存储。

### 精细持久化
1. 这个持久化需要我们手动进行开启。（注意，AOF开启之后，之前的数据都会丢失，所以要在一开始使用时就要配置好）
2. 开启的方法就是在配置 redis.conf，将 append only 改为 yes 。同时还可以更改文件名称，然后重新启动服务，这时精细化持久化就启动好了。
3. AOF持久化以日志的形式记录服务器所处理的每一个写、删除操作，查询操作不会记录，以文本的方式记录，可以打开文件看到详细的操作记录。
```
appendfsync always      #每次有数据修改发生时都会写入AOF文件。        
appendfsync everysec    #每秒钟同步一次，该策略为AOF的缺省策略。        
appendfsync no          #从不同步。高效但是数据不会被持久化。       
```  

## redis集群 {id="redis_6"}
Redis在3.0版本前只支持单实例模式，虽然支持主从模式、哨兵模式部署来解决单点故障，Redis在3.0版本以后就推出了集群模式。
1. 首先下载linux版本的redis安装包，解压。
2. 找到redis的conf文件，配置端口号，配置要开启的数据库，看有几个库，然后再配置redis开启后日志存储的位置，数据的存储位置，支持后台运行模式，在配置下开启集群模式，完成之后，保存，复制几分。
3. 然后启动，多启动几台单台服务，一般都是一组一组，我们一般都配置六台，总共三组。
4. 所有单台服务启动完毕后，通过`redis-trib.rb  create  --replicas 1  127.0.0.1:7000 127.0.0.1:7001  127.0.0.1:7002 127.0.0.1:7003  127.0.0.1:7004  127.0.0.1:7005`

--- 

Redis 集群搭建规划，由于集群至少需要6个节点（3主3从模式）。
1. 创建文件夹。我们计划集群中 Redis 节点的端口号为 9001-9006 ，端口号即集群下各实例文件夹。数据存放在 端口号/data 文件夹中。
2. 复制执行脚本。在 /usr/local/redis-cluster 下创建 bin 文件夹，用来存放集群运行脚本，并把安装好的 Redis 的 src 路径下的运行脚本拷贝过来。
3. 复制一个新 Redis 实例。我们现在从已安装好的 Redis 中复制一个新的实例到 9001 文件夹，并修改 redis.conf 配置。
```
port 9001                              # 每个节点的端口号
daemonize yes bind 192.168.119.131     # 绑定当前机器 IP
dir /usr/local/redis-cluster/9001/data/# 数据文件存放位置
pidfile /var/run/redis_9001.pid        # pid 9001和port要对应
cluster-enabled yes                    # 启动集群模式
cluster-config-file nodes9001.conf     # 9001和port要对应
cluster-node-timeout 15000
appendonly yes
```
4. 再复制出五个新 Redis 实例。我们已经完成了一个节点了，其实接下来就是机械化的再完成另外五个节点，唯一要修改的就是 redis.conf 中的所有和端口的相关的信息即可，其实就那么四个位置。
5. 调用 ruby 命令来进行创建集群。    
```Shell
/usr/local/redis-cluster/bin/redis-trib.rb create --replicas 1 192.168.119.131:9001 192.168.119.131:9002 192.168.119.131:9003 192.168.119.131:9004 192.168.119.131:9005 192.168.119.131:9006 
```

> 参考：[Redis 集群搭建详细指南](https://www.cnblogs.com/mafly/p/redis_cluster.html)

## redis缓存失效 {id="redis_7"}

### 设置过期时间      
1. expire key time(以秒为单位)--这是最常用的方式    
2. setex(String key, int seconds, String value)--字符串独有的方式      

注意：除了字符串自己独有设置过期时间的方法外，其他方法都需要依靠expire方法来设置时间。如果没有设置时间，那缓存就是永不过期。如果设置了过期时间，之后又想让缓存永不过期，使用persist key

### 三种过期策略

#### 定时删除（没人用）
1. 含义：在设置key的过期时间的同时，为该key创建一个定时器，让定时器在key的过期时间来临时，对key进行删除。
2. 优点：保证内存被尽快释放。
3. 缺点：若过期key很多，删除这些key会占用很多的CPU时间，在CPU时间紧张的情况下，CPU不能把所有的时间用来做要紧的事儿，还需要去花时间删除这些key。定时器的创建耗时，若为每一个设置过期时间的key创建一个定时器（将会有大量的定时器产生），性能影响严重。

#### 惰性删除
1. 含义：key过期的时候不删除，每次从数据库获取key的时候去检查是否过期，若过期，则删除，返回null。        
2. 优点：删除操作只发生在从数据库取出key的时候发生，而且只删除当前key，所以对CPU时间的占用是比较少的，而且此时的删除是已经到了非做不可的地步（如果此时还不删除的话，我们就会获取到了已经过期的key了）     
3. 缺点：若大量的key在超出超时时间后，很久一段时间内，都没有被获取过，那么可能发生内存泄露。（无用的垃圾占用了大量的内存）         

#### 定期删除     
1. 含义：每隔一段时间执行一次删除过期key操作。
2. 优点：通过限制删除操作的时长和频率，来减少删除操作对CPU时间的占用（处理"定时删除"的缺点），定期删除过期key。（处理"惰性删除"的缺点）     
3. 缺点：在内存友好方面，不如"定时删除"，在CPU时间友好方面，不如"惰性删除"。     
4. 难点：合理设置删除操作的执行时长（每次删除执行多长时间）和执行频率。（每隔多长时间做一次删除）（这个要根据服务器运行情况来定了）

## 怎么理解redis事务？

[//]: # (todo)

## redis哨兵 {id="redis_8"}
Redis哨兵是一个分布式系统，用于对Redis服务器进行监控，并在主服务器出现问题时自动进行故障转移。
1. 集群监控：负责监控Redis主服务器和从服务器进程是否正常工作。
2. 消息通知：如果某个Redis实例有故障，哨兵负责发送消息作为报警通知给管理员。
3. 故障转移：如果主服务器宕机，哨兵会自动转移到从服务器，选取一个从服务器作为新的主服务器，并将其他从服务器连接到新的主服务器。同时，哨兵还会告知客户端新的服务器地址。

此外，为了确保哨兵的高可用性，通常配置多个哨兵实例，这些实例之间会互相协同工作。当判断一个主服务器是否宕机时，需要大部分的哨兵都同意才能确认。


## redis的好处 {id="redis_5"}
1. 速度快。因为数据存在内存中，类似于 HashMap，HashMap 的优势就是查找和操作的时间复杂度都是O(1)。
2. 支持丰富数据类型。支持string、list、set、zset和hash。
3. 支持事务。操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行。
4. 丰富的特性。可用于缓存，消息，按key设置过期时间，过期后将会自动删除。

## redis在项目中遇到的问题 {id="redis_10"}

### 缓存穿透的问题      
1. 一般出现这样的问题，是因为当我们查询一条肯定不存在的数据的时候，缓存中没有，就会透过缓存来查询数据库，数据库也不存在，这样就会将值保存在缓存中最后还是缓存和数据库中都没有，如果一直访问这条数据。我们就对数据库进行频繁的查询给数据库带来压力。        
2. 当查询的时候，如果缓存和数据库中都没有，我们就将这个数据以空的形式存放在缓存中，（或者是给一个false的标示）这样就不用去数据库就可以知 道不存在，减少对数据库查询的次数。当我们这个值发生改变的时候，我们在重新赋值。      

### 并发情况              
1. 当我们大量访问都是查询一个缓存中没有的数据时，这样就会去数据库中进行查询，可能会造成数据库岩机。
2. 在查询的时候，我给它添加一个同步锁，只有第一条数据去，数据库中查询并返回到redis中后才能查询，这是数据库中已近存在了值，这样可以避免；

### 雪崩    
1. 大量数据的访问缓存超时，这样用户就会访问到数据库，第一台数据库崩溃了，访问就会到第三台数据库进行查询，这样就会导致额第二台崩溃。            
2. 就是设置失效时间，不要一起失效，或者是设置在访问少的时候，或者设置永远不失效。

## redis的主要使用场景？ {id="redis_14"}
1. 缓存：Redis提供了一个非常快速的内存存储系统，可以作为数据库的缓存层，从而加快数据的读取速度。通过将常用的数据存储在Redis中，可以减少对数据库的访问，从而提高应用程序的性能。
2. 排行榜：Redis的有序集合数据类型可以用于实现各种复杂的排行榜应用，例如月度销量榜单、商品按时间的上新排行榜等。
3. 计数器：Redis的原子操作可以用于实现计数器功能，例如电商网站商品的浏览量、视频网站视频的播放数等。由于Redis是单线程的，可以避免并发问题，保证计数的准确性和一致性。这类操作如果用MySQL，频繁的读写会带来相当大的压力。
4. 分布式会话：在分布式系统中，可以使用Redis来管理会话，从而避免使用Cookie等客户端存储机制所带来的安全问题。通过将会话数据存储在Redis中，可以实现跨多个服务器的会话共享和一致性。
5. 分布式锁：在分布式系统中，当多个节点需要访问共享资源时，可以使用Redis来实现分布式锁。通过Redis的原子操作，可以确保在任何时候只有一个节点可以访问共享资源，从而避免竞态条件和数据不一致的问题。
6. 消息队列：虽然Redis不是专门的消息队列系统，但它可以通过发布/订阅模式或列表数据类型来实现消息队列的功能。与传统的消息队列系统相比，Redis的消息队列实现更为简单和快速。
7. 分布式缓存：通过Redis的集群模式，可以实现分布式缓存。在集群模式下，多个Redis节点可以一起工作，提供更大的缓存容量和更高的可用性。
8. 限速器：比较典型的使用场景是限制某个用户访问某个API的频率，常用的有抢购时，防止用户疯狂点击带来不必要的压力。
9. 好友关系：利用集合的一些命令，比如求交集、并集、差集等。可以方便搞定一些共同好友、共同爱好之类的功能。

总之，Redis是一个非常灵活和强大的工具，可以在各种场景中实现各种功能，包括缓存、排行榜、计数器、分布式会话、分布式锁、消息队列和分布式缓存等。

## Redis不适用的场景 {id="redis_11"}
1. 需要全量历史数据：Redis是基于内存的存储系统，因此对于需要长期存储大量数据的场景，Redis可能不是最佳选择。
2. 需要高可靠性的数据：由于Redis的数据是存储在内存中的，一旦发生故障可能会导致数据丢失，因此对于需要高可靠性数据的场景，Redis可能不是最佳选择。
3. 需要大量写操作的场景：对于需要大量写操作的场景，Redis可能会面临性能问题，因为每次写操作都需要将数据写入到内存中，这可能会导致内存压力增大。
4. 需要大量并发读写的场景：Redis虽然支持高并发读写，但是在极端情况下仍然可能面临性能问题。
5. 需要跨多个地域的数据同步：如果需要在多个地域之间同步数据，Redis可能不是最佳选择，因为其数据同步机制可能无法满足跨地域同步的需求。

## redis电商项目中的使用 {id="redis_12"}
1. 由于Redis是一个基于key和value的支持多种数据类型的可进行持久化的内存数据库，是一个服务级的缓存。它支持对象，集合，map，字符串，json，一般存的都是可序列号对象。（可序列号的对象是指将对象转化为二进制，反序列号是指将二进制返还成对象，session，application，request为非序列号对象）
2. 在我们的项目中，为了保证redis不会因为占用内存过大而导致系统宕机，通常将redis当做缓存服务器使用，用redis缓存分类列表，品牌列表，热销商品，推荐商品以及该商品的关联商品等。
3. 使用jedis作为客户端，考虑到性能问题使用了jedis连接池。并考虑到redis服务器的高可用性，可以做redis的主从复制，通过哨兵来使主服务器宕机时，从服务器自动转化为主服务器继续提供服务（redis集群情况下，多个redis存储的内容通常是一样的，链接的时候，我们只链接主redis，如果主redis挂掉，哨兵会随机选取在从redis中选取其中一个redis成为主redis，继续返回内容）。
4. redis和spring整合之后获取一个模板工具叫redisTemplate。get方法取，set方法存，set方法有两种，第一个有两个参数，key和value, 第二个set方法有三个参数，除了key和value，还有超时。我们用的时候，做一个if判断，拿方法名和参数作为key值，去redis里面取，取到了就展示 ，没有的话就存进redis，下次使用的话就直接取。

### 登录验证码
我们在项目中用redis来做缓存，我们在登陆的时候将用户登陆时获取的验证码存放到了redis中，并设置了验证码的有效期为30分钟，当用户登陆时我们从redis中获取出用户的点击时获取的验证码，如果获取不到直接返回前台，并返回相应的错误码，否者取出redis中的验证码和前台传过来的验证码进行比较，我们还用redis缓存了前台首页的名师、网站统计文章 好文推荐、网站最近30条活跃统计等。

### 秒杀业务
把你要卖出的商品比如10个商品放到缓存中，然后在redis里设置一个计数器来记录请求数，这个请求数你可以以你要秒杀卖出的商品数为基数，比如你想卖出10个商品，只允许100个请求进来。那当计数器达到100的时候，后面进来的就显示秒杀结束，这样可以减轻你的服务器的压力。然后根据这100个请求，先付款的先得后付款的提示商品已秒杀完。

### 购物车
redis 在项目模块购物车中应用的比较多，假设购物车模块是与数据库交互的，每个人添加一个购物车或者删除一个购物车，都会与数据库交互一次，如果有人恶意破坏，几百几千人一起添加删除购物车就是不买，对数据库的压力特别大，严重可能损坏数据库，以前的电商有好多就是因为这个而被恶意破坏，所以用到了redis，每个人对购物车新增和删除的时候是对数据库的操作，只有到确定购买的时候才对数据库进行操作，减轻数据库压力，防止恶意操作。

### 网站首页排行榜
网站首页的排行榜每个用户登录都会看到，访问量较大，而且会定时更新，我们把用户的浏览量存如mongodb中，每天晚上凌晨两点时启动定时器，然后通过后台算法计算出首页的排行榜信息，把计算出来的排行榜信息存入redis中，前台通过ajax异步加载把数据加载出来。

## redis在项目中的流程 {id="redis_2"}
1. 第一次访问请求的时候，直接查询数据库，将数据存到redis中，再将数据返回到页面展示。
2. 后续再次请求时，查redis。查到结果———返回页面，没有结果———查询数据库，数据存到redis中再将数据返回到页面展示。


## redis各种实现的区别 {id="redis_9"}
Jedis、Redisson和Lettuce都提供了基于Redis操作的Java API，只是封装程度，具体实现稍有不同。

1. Jedis：Jedis是Redis的Java实现客户端，支持基本的数据类型如：String、Hash、List、Set、Sorted Set。其特点包括使用阻塞的I/O，方法调用同步，程序流需要等到socket处理完I/O才能执行，不支持异步操作。Jedis客户端实例不是线程安全的，需要通过连接池来使用Jedis。
2. Redisson：Redisson提供了分布式锁、分布式集合等功能，并可通过Redis支持延迟队列。
3. Lettuce：Lettuce用于线程安全同步、异步和响应使用，支持集群、Sentinel、管道和编码器。基于Netty框架的事件驱动的通信层，其方法调用是异步的。Lettuce的API是线程安全的，所以可以操作单个Lettuce连接来完成各种操作。

> 参考：[SpringBoot 操作 Redis的各种实现](https://zhuanlan.zhihu.com/p/403167862)

## redis和Memcached的区别
Redis和Memcached都是内存数据存储系统，都用作内存中的键值数据存储。

|  特点   |                  Redis                   |           Memcached            |  
|:-----:|:----------------------------------------:|:------------------------------:|  
| 数据结构  |       支持多种数据结构，如字符串、散列、列表、集合、有序集合等       |     仅支持简单的键值对存储，通常是字符串和整数      |  
| 执行速度  |                   通常较慢                   |              通常较快              |  
|  复制   |        支持主从复制，允许从属服务器成为主服务器的精确副本         |             不支持复制              |  
|  线程   |                   单线程                    |              多线程               |  
|  键长度  |                  最大2GB                   |            最大250字节             |  
| 存储方式  |            可以将一些很久没用到的值交换到磁盘             |           不支持数据交换到磁盘           |  
| 过期策略  |         通过命令设置，如`expire name 10`         | 在设置时指定，如`set key1 0 0 8`，即永不过期 |  
|  持久化  | 支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用 |            不支持数据持久化            |  
| 分布式处理 |              支持主从结构，进行分布式处理              |          在分布式方面的处理较弱           |

## redis和mongodb的区别
1. mongodb 是非关系数据，基于bson格式的数据库，有关键字可以进行分页，姓名模糊匹配，大于小于等，mongodb是最向关系型数据库的非关系行数据库。
2. Redis 是一个缓存的技术，mongodb的数据都存在硬盘当中，而redis数据是存放在内存当中的，只是它支持持久化到硬盘的操作，所以可以理解为非关系数据库，但需要注意的是，redis是通过键值对的存储方式，不支持模糊，条件查询

