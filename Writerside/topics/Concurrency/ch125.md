# JVM优化

## `主要调优的目的`
1.	控制GC的行为.GC是一个后台处理,但是它也是会消耗系统性能的,因此经常会根据系统运行的程序的特性来更改GC行为
2.	控制JVM堆栈大小.一般来说,JVM在内存分配上不需要你修改,(举例)但是当你的程序新生代对象在某个时间段产生的比较多的时候,就需要控制新生代的堆大小.同时,还要需要控制总的JVM大小避免内存溢出
3.	控制JVM线程的内存分配.如果是多线程程序,产生线程和线程运行所消耗的内存也是可以控制的,需要通过一定时间的观测后,配置最优结果

## 可以做的有
`年轻代大小选择`
1.	响应时间优先的应用：尽可能设大，直到接近系统的最低响应时间限制（根据实际情况选择）。在此种情况下，年轻代收集发生的频率也是最小的。同时，减少到达年老代的对象。
2.	吞吐量优先的应用：尽可能的设置大，可能到达Gbit的程度。因为对响应时间没有要求，垃圾收集可以并行进行，一般适合8CPU以上的应用。

`年老代大小选择`
1. 响应时间优先的应用：年老代使用并发收集器，所以其大小需要小心设置，一般要考虑并发会话率和会话持续时间等一些参数。如果堆设置小了，可以会造成内存碎片、高回收频率以及应用暂停而使用传统的标记清除方式；如果堆大了，则需要较长的收集时间。最优化的方案，一般需要参考以下数据获得：
- 并发垃圾收集信息
- 持久代并发收集次数
- 传统GC信息
- 花在年轻代和年老代回收上的时间比例  
  减少年轻代和年老代花费的时间，一般会提高应用的效率
2. 吞吐量优先的应用：一般吞吐量优先的应用都有一个很大的年轻代和一个较小的年老代。原因是，这样可以尽可能回收掉大部分短期对象，减少中期的对象，而年老代尽存放长期存活对象。

`较小堆引起的碎片问题`  
因为年老代的并发收集器使用标记、清除算法，所以不会对堆进行压缩。当收集器回收时，他会把相邻的空间进行合并，这样可以分配给较大的对象。但是，当堆空间较小时，运行一段时间以后，就会出现“碎片”，如果并发收集器找不到足够的空间，那么并发收集器将会停止，然后使用传统的标记、清除方式进行回收。如果出现“碎片”，可能需要进行如下配置：
1.	-XX:+UseCMSCompactAtFullCollection：使用并发收集器时，开启对年老代的压缩。
2.	-XX:CMSFullGCsBeforeCompaction=0：上面配置开启的情况下，这里设置多少次Full GC后，对年老代进行压缩

## jvm优化
网上搜7条 优化方法    
1. 多数的Java应用不需要在服务器上进行GC优化；
2. 多数导致GC问题的Java应用，都不是因为我们参数设置错误，而是代码问题；
3. 在应用上线之前，先考虑将机器的JVM参数设置到最优（最适合）；
4. 减少创建对象的数量；
5. 减少使用全局变量和大对象；
6. GC优化是到最后不得已才采用的手段；
7. 在实际使用中，分析GC情况优化代码比优化GC参数要多得多；    
JVM 优化主要是解决java的 GC （垃圾回收）问题。   
JVM 的使用过程中各代有，年轻带主要存放，新创建对象。 年老代，年老代存放从年轻代存活的 对象。Perm（持久代）用 于存放静态文件，如今Java类、方法等。一般持久代可以设置大一点。     
GC优化的目的有两个：   
1. 将转移到老年代的对象数量降低到最小；    
2. 减少full GC的执行时间；   
为了达到上面的目的，一般地，你需要做的事情有：          
1. 减少使用全局变量和大对象；   
2. 调整新生代的大小到最合适；   
3. 设置老年代的大小为最合适；   
4. 选择合适的GC收集器；    
【垃圾回收（GC收集器）:串行收集器、并行收集器、并发收集器。   
串行处理器：    
--适用情况：数据量比较小（100M左右）；单处理器下并且对响应时间无要求的应用。   
--缺点：只能用于小型应用   
并行处理器     
--适用情况：“对吞吐量有高要求”，多CPU、对应用响应时间无要求的中、大型应用。举例：后台处理、科学计算。（例如 ERP 银行系统）     
--缺点：应用响应时间可能较长   
并发处理器：      
--适用情况：“对响应时间有高要求”，多CPU、对应用响应时间有较高要求的中、大型应用。举例：Web服务器/应用服务器、电信交换、集成开发环境。（例如互联网网站）】      
5. 设置jvm堆大小 ，32bit 1.5-2G  ，64bit 可以超过 2G ，新版的JDK 每个线程的堆大小在1M改变这个线程所占用的堆大小 ，可以生成更多的线程，一般项目里线程数不能超过5000个。     


# Jre jdk jvm
首先jvm 是java虚拟机，是完成java程序一次编译到处执行，跨平台关键所在。不同的平台使用不同的jvm。Java源文件是先通过编译器编译成字节码文件，然后交给jvm运行的。   
jre是java运行时环境，运行java程序的必要因素，jre里包含jvm和一些其他的核心类库。    
jdk是开发工具包里面包含了开发的工具，如java javac等命令。而且jdk中包含jre。所以如果安装了jdk就不需要安装jre。   
三者的关系 是 jdk包含jre ，jre包含jvm。   
