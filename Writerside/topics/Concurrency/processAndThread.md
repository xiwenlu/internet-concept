# 进程和线程

## 什么是进程和线程
`进程`资源分配的最小单位，`线程`程序执行的最小单位。

## 进程和线程的区别
进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个程序至少有一个进程,一个进程至少有一个线程。

## 什么叫线程安全什么叫线程不安全
多线程这块我在工作中也有涉及到，我对于线程安全不安全是这么理解的，我认线程的安全与否与java类本身无关，也就是说不能说StringBuffer是线程安全的，stringBuilder是线程不安全的，或hashMap是线程不安全的，HashTable是线程安全的，这几个类本身是与线程无关的，只有当它处于多线程的环境当中时，才可能引发线程安全不安全的问题，StringBuffer与stringBuilder的线程安全与否取决于他的append方法前面有没有开启互斥锁，对于HashMap与HashTable的线程与否，主要取决于put方法前面有没有开启线程的互斥锁，（线程本身就自带互斥锁，只不过默认不开启，当看到synchronized时会开启互斥）。 

通过我的工作经验，我感觉只要不让多个线程同时操作同一个对象，一般不会涉及到线程不安全这种问题，只有到多个线程同时操作同一个对象的时候才有可能引发线程安全问题

## 什么是线程安全
如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。       
或者说：一个类或者程序所提供的接口对于线程来说是原子操作，或者多个线程之间的切换不会导致该接口的执行结果存在二义性,也就是说我们不用考虑同步的问题，那就是线程安全的。



## 什么是竞态条件？举例说明
当两个线程竞争同一资源时，如果对资源的访问顺序敏感，就称存在竞态条件。导致竞态条件发生的代码区称作临界区。  
在临界区中使用适当的同步就可以避免竞态条件。   
临界区实现方法有两种，一种是用synchronized，一种是用Lock显式锁实现。

[什么是竞态条件？举例说明](https://www.cnblogs.com/xiaozhijing/p/7919216.html)


## 解决线程安全问题的方案？
1. 通过加synchronized同步锁
2. 避免使用全局变量和静态变量
3. ThreadLocal类用来提供线程内部的局部变量

## 宋氏多线程
线程呢主要是有三种方式，一种是继承thread类，另一种是实现runable接口，还有一种是使用线程池，在我们开发过程中主要还是使用，实现runable接口配合线程池多一些，因为如果使用继承thread类的话，我们的线程类就无法在继承其他的父类了，但是呢使用runable接口的话还可实现其他的接口也能继承其他的父类，互不影响，还有就是线程池，线程池呢据我了解常用的有4个，分别是newCachedThreadPool、newFixedThreadPool、newScheduledThreadPool、newSingleThreadExecutor。newCachedThreadPool是一个缓存线程池，如果线程池的长度超过处理需要，可灵活回收空闲的线程，若没有可回收的线程，就新建一个线程，适用于：执行很多短期异步的小程序或者负载较轻的服务器；newFixedThreadPool是一个定长线程池，可以控制线程最大的并发数量，超过的线程会在队列中等待，适用于：执行长期的任务，性能好很多； newScheduledThreadPool是一个定时线程池，支持定时及周期性任务的执行，创建一个定长线程池，支持定时及周期性任务执行；newSingleThreadExecutor是一个单线程池，它只会用唯一的工作线程来执行任务，保证所有的任务按照指定的优先级执行，适用于：周期性执行任务的场景。线程呢有6种状态 ，分别是新建状态、可运行状态、就绪状态、运行状态、阻塞状态、死亡状态。新建状态就是新创建了一个线程对象，可运行状态就是新建的线程调用strat方法后变成可运行状态，当这个线程获取到cpu分配的资源后变成就绪状态，调用run方法后线程变成运行状态，阻塞状态就是线程因为某种原因放弃CPU使用权，暂时停止运行，当阻塞状态完成后线程就会变成可运行状态，继续往下执行，直到线程变为死亡状态。阻塞状态分为等待阻塞、同步阻塞、其他阻塞，等待阻塞就是运行的线程执行wait()方法，JVM会把该线程放入等待池中,同步阻塞就是运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池中。其他阻塞就是运行的线程执行sleep方法或join方法，或者发出了IO请求时，JVM会把该线程设为阻塞状态。当sleep状态超时、join等待线程终止或者超时、或者IO处理完毕时，线程重新转入可运行状态。死亡状态：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。


## 如何确保N个线程可以访问N个资源同时又不导致线程死锁？
多线程产生死锁需要四个条件，分别是互斥性，保持和请求，不可剥夺性还有要形成闭环，这四个条件缺一不可，只要破坏了其中一个条件就可以破坏死锁，其中最简单的方法就是线程都是以同样的顺序加锁和释放锁     
多线程产生死锁的四个必要条件：     
互斥条件：一个资源每次只能被一个进程使用。           
保持和请求条件：一个进程因请求资源而阻塞时，对已获得资源保持不放。           
不可剥夺条件：进程已获得资源，在未使用完成前，不能被剥夺。          
循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。

## 什么是多线程
1个进程中可以开启多条线程，每条线程可以并行（同时）执行不同的任务
进程 -> 车间，线程 -> 车间工人
多线程技术可以提高程序的执行效率，比如同时开启3条线程分别下载3个文件

## 多线程的原理
同一时间，CPU只能处理1条线程，只有1条线程在工作（执行）      
多线程并发（同时）执行，其实是CPU快速地在多条线程之间调度（切换）      
如果CPU调度线程的时间足够快，就造成了多线程并发执行的假象      
思考：如果线程非常非常多，会发生什么情况？       
CPU会在N多线程之间调度，CPU会累死，消耗大量的CPU资源     
每条线程被调度执行的频次会降低（线程的执行效率降低）


## 如何用多线程实现生产者和消费者？
主要关键点 wait和notify的结合使用。
1. 因为生产者跟消费者共享一块区域,这里我将这块区域定义为“仓库”。
2. 仓库是有容量上限的,当数量达到上限后,生产者不允许继续生产产品.当前线程进入等待状态,等待其他线程唤醒。
3. 当仓库没有产品时，消费者不允许继续消费，当前线程进入等待状态,等待其他线程唤醒。

生产者的主要作用是生成一定量的数据放到缓冲区中，然后重复此过程。与此同时，消费者也在缓冲区消耗这些数据。该问题的关键就是要保证生产者不会在缓冲区满时加入数据，消费者也不会在缓冲区中空时消耗数据。
要解决该问题，就必须让生产者在缓冲区满时调用wait方法（要么干脆就放弃数据），等到下次消费者消耗缓冲区中的数据的时候，生产者才能通过notify方法被唤醒，开始往缓冲区添加数据。同样，也可以让消费者在缓冲区空时调用wait方法进入休眠，等到生产者往缓冲区添加数据之后，再通过notify方法唤醒消费者
死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。


## 死锁如果产生如何避免？
多线程产生死锁需要四个条件，分别是互斥性，保持和请求，不可剥夺性还有要形成闭环，这四个条件缺一不可，只要破坏了其中一个条件就可以破坏死锁，其中最简单的方法就是线程都是以同样的顺序加锁和释放锁         
`多线程产生死锁的四个必要条件：`    
1. 互斥条件：一个资源每次只能被一个进程使用。       
2. 保持和请求条件：一个进程因请求资源而阻塞时，对已获得资源保持不放。       
3. 不可剥夺条件：进程已获得资源，在未使用完成前，不能被剥夺。       
4. 循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。     
有序的资源分配法，以同样的顺序加锁和释放锁    

## 死锁产生的原因？
是由于访问共享资源顺序不当造成的。简单的说，死锁就是指两个或两个以上的线程在执行过程中，因争夺资源而造成的一种互相等待的现象，如果没有外力作用，他们都将无法继续执行下去。
