# jvm

## 堆和栈的区别
JVM是基于堆栈的虚拟机.JVM为每个新创建的线程都分配一个堆栈.也就是说,对于一个Java程序来说，它的运行就是通过对堆栈的操作来完成的。堆栈以帧为单位保存线程的状态。JVM对堆栈只进行两种操作:以帧为单位的压栈和出栈操作。       

`差异:`
1. 堆内存用来存放由new创建的对象和数组。
2. 栈内存用来存放方法或者局部变量等
3. 堆是先进先出，后进后出
4. 栈是后进先出，先进后出

`相同:`
1. 都是属于Java内存的一种 
2. 系统都会自动去回收它，但是对于堆内存一般开发人员会自动回收它

## 堆和栈的区别
Java中的内存分为两种，堆内存和栈内存
1. 栈内存  
   在函数当中定义的基本类型变量和对象引用变量，java都会给它分配栈内存。一旦离开作用域，这些内存都会被释放掉。
   在函数当中的代码块当中定义的变量，java也会给它分配栈空间。

2. 堆内存  
   在java当中使用new关键字创建的内存是在堆上分配的，这些内存是由java虚拟机的垃圾回收器来自动管理的。在栈中可以定义特殊的引用变量指向在堆内存中分配的对象或者数组的首地址，通过这些引用变量来操作堆内存。当没有引用指向这些堆中的内存的时候，这些内存就变为了不可访问的内存，也就是变为了垃圾，但是此时并不会被回收。GC垃圾回收器，会在一个不确定的时间将这些垃圾进行回收。

## Java中堆和栈的比较 {id="java_1"}
1. 首先在Java中程序员都不可以直接操作堆和栈
2. new创建的对象存在于堆中，局部变量存在于栈中。在堆中定义的对象会在栈中存其的首地址，方便快速访问。
3. 栈的存取方式为先进后出，堆为先进先出
4. 栈的访问速度快于堆
5. 栈的生命周期一般短，用完即释放。堆相对较长，用完不一定释放，由操作系统的内存回收机制决定

## 怎么获取 Java 程序使用的内存？堆使用的百分比？
可以通过java.lang.Runtime 类中与内存相关方法来获取剩余的内存，总内存及最大堆内存。通过这些方法你也可以获取到堆使用的百分比及堆内存的剩余空间。Runtime.freeMemory() 方法返回剩余空间的字节数，Runtime.totalMemory() 方法总内存的字节数，Runtime.maxMemory() 返回最大内存的字节数。


## JVM优化 {id="jvm_1"}

### `主要调优的目的`
1.	控制GC的行为.GC是一个后台处理,但是它也是会消耗系统性能的,因此经常会根据系统运行的程序的特性来更改GC行为
2.	控制JVM堆栈大小.一般来说,JVM在内存分配上不需要你修改,(举例)但是当你的程序新生代对象在某个时间段产生的比较多的时候,就需要控制新生代的堆大小.同时,还要需要控制总的JVM大小避免内存溢出
3.	控制JVM线程的内存分配.如果是多线程程序,产生线程和线程运行所消耗的内存也是可以控制的,需要通过一定时间的观测后,配置最优结果

### 可以做的有
`年轻代大小选择`
1.	响应时间优先的应用：尽可能设大，直到接近系统的最低响应时间限制（根据实际情况选择）。在此种情况下，年轻代收集发生的频率也是最小的。同时，减少到达年老代的对象。
2.	吞吐量优先的应用：尽可能的设置大，可能到达Gbit的程度。因为对响应时间没有要求，垃圾收集可以并行进行，一般适合8CPU以上的应用。

`年老代大小选择`
1. 响应时间优先的应用：年老代使用并发收集器，所以其大小需要小心设置，一般要考虑并发会话率和会话持续时间等一些参数。如果堆设置小了，可以会造成内存碎片、高回收频率以及应用暂停而使用传统的标记清除方式；如果堆大了，则需要较长的收集时间。最优化的方案，一般需要参考以下数据获得：
- 并发垃圾收集信息
- 持久代并发收集次数
- 传统GC信息
- 花在年轻代和年老代回收上的时间比例  
  减少年轻代和年老代花费的时间，一般会提高应用的效率
2. 吞吐量优先的应用：一般吞吐量优先的应用都有一个很大的年轻代和一个较小的年老代。原因是，这样可以尽可能回收掉大部分短期对象，减少中期的对象，而年老代尽存放长期存活对象。

`较小堆引起的碎片问题`  
因为年老代的并发收集器使用标记、清除算法，所以不会对堆进行压缩。当收集器回收时，他会把相邻的空间进行合并，这样可以分配给较大的对象。但是，当堆空间较小时，运行一段时间以后，就会出现“碎片”，如果并发收集器找不到足够的空间，那么并发收集器将会停止，然后使用传统的标记、清除方式进行回收。如果出现“碎片”，可能需要进行如下配置：
1.	-XX:+UseCMSCompactAtFullCollection：使用并发收集器时，开启对年老代的压缩。
2.	-XX:CMSFullGCsBeforeCompaction=0：上面配置开启的情况下，这里设置多少次Full GC后，对年老代进行压缩

## jvm优化

1. 多数的Java应用不需要在服务器上进行GC优化；
2. 多数导致GC问题的Java应用，都不是因为我们参数设置错误，而是代码问题；
3. 在应用上线之前，先考虑将机器的JVM参数设置到最优（最适合）；
4. 减少创建对象的数量；
5. 减少使用全局变量和大对象；
6. GC优化是到最后不得已才采用的手段；
7. 在实际使用中，分析GC情况优化代码比优化GC参数要多得多；    
   JVM 优化主要是解决java的 GC （垃圾回收）问题。   
   JVM 的使用过程中各代有，年轻带主要存放，新创建对象。 年老代，年老代存放从年轻代存活的 对象。Perm（持久代）用 于存放静态文件，如今Java类、方法等。一般持久代可以设置大一点。     
   GC优化的目的有两个：
1. 将转移到老年代的对象数量降低到最小；
2. 减少full GC的执行时间；   
   为了达到上面的目的，一般地，你需要做的事情有：
1. 减少使用全局变量和大对象；
2. 调整新生代的大小到最合适；
3. 设置老年代的大小为最合适；
4. 选择合适的GC收集器；    
   【垃圾回收（GC收集器）:串行收集器、并行收集器、并发收集器。   
   串行处理器：    
   --适用情况：数据量比较小（100M左右）；单处理器下并且对响应时间无要求的应用。   
   --缺点：只能用于小型应用   
   并行处理器     
   --适用情况：“对吞吐量有高要求”，多CPU、对应用响应时间无要求的中、大型应用。举例：后台处理、科学计算。（例如 ERP 银行系统）     
   --缺点：应用响应时间可能较长   
   并发处理器：      
   --适用情况：“对响应时间有高要求”，多CPU、对应用响应时间有较高要求的中、大型应用。举例：Web服务器/应用服务器、电信交换、集成开发环境。（例如互联网网站）】
5. 设置jvm堆大小 ，32bit 1.5-2G  ，64bit 可以超过 2G ，新版的JDK 每个线程的堆大小在1M改变这个线程所占用的堆大小 ，可以生成更多的线程，一般项目里线程数不能超过5000个。


## jre、jdk和jvm区别
三者的关系是jdk包含jre，jre包含jvm。
1. jvm是java虚拟机，是完成java程序一次编译到处执行，跨平台关键所在。不同的平台使用不同的jvm。Java源文件是先通过编译器编译成字节码文件，然后交给jvm运行的。   
2. jre是java运行时环境，运行java程序的必要因素，jre里包含jvm和一些其他的核心类库。    
3. jdk是开发工具包里面包含了开发的工具，如java javac等命令。而且jdk中包含jre。所以如果安装了jdk就不需要安装jre。   
 
## 什么情况下内存数据会丢失？

在以下情况下，内存中的数据可能会丢失：

1. 程序结束：当程序结束运行时，操作系统通常会回收该程序使用的所有内存，包括其中的数据。

2. 电源中断：如果计算机突然断电或重启，内存中的数据将会丢失。

3. 内存溢出：如果程序尝试使用超过其分配的内存，操作系统可能会终止程序，导致内存中的数据丢失。

4. 系统崩溃：在某些情况下，操作系统可能会崩溃，导致内存中的数据丢失。

5. 内存管理错误：如果程序错误地管理内存（例如，通过指针访问未分配的内存或已释放的内存），可能会导致数据丢失或损坏。

请注意，这些情况通常只影响内存中的数据。持久化存储（如硬盘上的文件）通常不会受到这些情况的影响，除非发生硬件故障或数据未正确写入磁盘。