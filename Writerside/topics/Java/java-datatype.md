# java数据类型

## java的数据类型 {id="java_datatype"}
Java是一种强类型语言，这意味着在声明变量时必须指定其数据类型。Java支持多种数据类型，包括基本数据类型和引用数据类型。

### 基本数据类型
原始数据类型也称为基本数据类型，它们是Java语言中预定义的一些简单数据类型。

#### 整型
1. byte（字节型）：8位有符号二进制整数，范围从-128到127。
2. short（短整型）：16位有符号二进制整数，范围从-32768到32767。
3. int（整型）：32位有符号二进制整数，范围从-2^31到2^31-1。
4. long（长整型）：64位有符号二进制整数，范围从-2^63到2^63-1。
5.
#### 浮点型
1. float（单精度浮点型）：32位IEEE 754单精度浮点数。
2. double（双精度浮点型）：64位IEEE 754双精度浮点数。

#### 字符型char
16位Unicode字符，范围从'\u0000'（即0）到'\uffff'（即65,535）。

#### 布尔型boolean
只有两个可能的值，true和false。

### 引用数据类型
1. 类（Class）：用于定义对象的蓝图或模板。
2. 接口（Interface）：是类的一个类型，用于定义一组方法，这些方法可以在类中被实现。
3. 数组（Array）：可以包含多个相同类型的元素。

请注意，所有基本数据类型都是按值传递的，而对象引用是按值传递对象的引用。这意味着当你将一个对象作为参数传递给一个方法时，实际上传递的是对象的引用，而不是对象本身。

## 什么是java自动隐式转换？ {id="java_convert"}
1. 在Java中，当进行算术运算时，如果操作数是byte、short或char类型，Java会自动进行类型提升（也称为类型转换或隐式转换）。具体来说，这些类型会被提升为int类型。
2. 这种自动类型提升是为了简化编程和提高代码的可读性。通过自动类型提升，程序员可以专注于编写逻辑和算法，而不需要担心数据类型转换的细节。

## 什么是java的强制类型转换？ {id="java_2"}
在Java中，强制类型转换是一种将一种数据类型强制转换为另一种数据类型的机制。当需要将一种数据类型转换为另一种不兼容的数据类型时，就需要使用强制类型转换。

## 什么是java的自动拆装箱？ {id="java_pack"}
Java的自动拆装箱是指基本类型和对应的包装类之间的自动转换。
当基本类型作为参数传递给方法时，Java会自动将其转换为对应的包装类对象；当包装类对象被赋值给基本类型变量时，Java会自动将其拆箱为基本类型值。这种自动转换功能简化了代码编写，提高了开发效率。

## long转为int会出现什么问题？
long是64位，int是32位。当使用强制类型把long转换为int类型有可能会出现负数问题。

## 什么时候java的自动装箱不起作用？ {id="java_pack_error"}
1. 当存在重载的方法，其中一个方法使用基本类型作为唯一参数，而另一个方法使用该基本类型的包装类作为唯一参数时，自动装箱可能不会按预期工作。在这种情况下，编译器可能会选择使用基本类型的方法，而不是包装类的方法，从而导致自动装箱不起作用。
```Java
class Test {  
    public static void add(int i) {  
        System.out.println("int add");  
    }  
      
    public static void add(Integer i) {  
        System.out.println("Integer add");  
    }  
}
```
2. 当涉及到方法的返回类型时，自动装箱也可能不起作用。如果方法的返回类型是基本类型，而该方法被重写为返回包装类对象时，编译器可能会选择使用基本类型的方法，而不是包装类的方法，从而导致自动装箱不起作用。
```Java
class Test {  
    public static int add(int i) {  
        return i + 1;  
    }  
      
    public static Integer add(Integer i) {  
        return i + 1;  
    }  
}
```

## 基本数据类型的转换
1. 默认转换。发生在数据类型较小的变量转换成数据类型较大的变量时
2. 强制转换。当较大的类型转换成较小的类型时,可能会出现损失精度
3. boolean类型不能和任何类型发生转换

## int和Integer的区别
1. 类型：Integer是int的包装类，int是Java的基本数据类型。
2. 变量声明与实例化：Integer变量必须实例化后才能使用，而int变量不需要实例化。
3. 数据存储：Integer实际上是对象的引用，存储的是指向实际值的指针，而int是直接存储数据值。
4. 默认值：Integer的默认值是null，而int的默认值是0。
5. 内存占用：由于Integer是对象，因此它需要存储对象的元数据，所占内存多于int。
6. 比较：当使用“==”比较Integer和int时，结果可能不同。因为“==”比较的是两个对象的引用是否相等，而不是它们的内容是否相等。而Integer和int的比较结果取决于具体的实现。

## 基本类型对应的包装类

|  基本类型   |    包装类    |  
|:-------:|:---------:|  
|  byte   |   Byte    |  
|  short  |   Short   |  
|   int   |  Integer  |  
|  long   |   Long    |  
|  float  |   Float   |  
| double  |  Double   |  
|  char   | Character |  
| boolean |  Boolean  |

### 转换方法
```Java
Integer integer = Integer.valueOf(100);   // 基本数据类型转包装类
int i = Integer.parseInt("100");          // 包装类转基本数据类型
```

## java数组的特点
你可以使用索引来访问数组中的元素。索引从0开始，到数组长度减1。
1. 固定大小：一旦创建了数组，其大小就不能改变。这意味着如果你尝试添加或删除元素，你实际上是创建一个新的数组（对于ArrayList），或者直接改变元素的值（对于基础数据类型和对象引用类型）。
2. 引用类型：数组是引用类型，这意味着它们存储的是对象的内存地址，而不是对象本身。对于基础数据类型，数组存储的是实际的值。
3. 多维性：Java支持一维和多维数组，多维数组实际上是数组的数组。
4. 速度快：访问数组的元素通常比在ArrayList等动态数组中访问元素要快。
5. 无null元素：所有的数组都有一个初始值，对于基础数据类型，通常是0或false，对于对象引用类型，通常是null。
6. 用于表示集合：数组可以用于表示一组相同类型的元素，常用于表示集合。
7. 内存连续：在内存中，数组是连续存储的。
8. 长度可查：可以通过数组的“length”属性获取数组的长度。
9. 不支持动态添加/删除元素：由于数组的大小在创建时确定并且不能更改，因此不支持动态添加或删除元素。
10. 性能考虑：对于大量数据的处理，使用数组可能会比使用ArrayList等动态数组更高效，因为数组在内存中是连续存储的，这使得某些操作（如随机访问）更快。然而，对于需要频繁添加和删除元素的场景，ArrayList可能更合适，因为这些操作在ArrayList中更高效。

## 下面程序打印结果
```Java
    public static void main(String[] args) {
        Integer n1 = new Integer(30);
        Integer n2 = new Integer(30);
        int n3 = 30;
        Integer n4 = 30;
        Integer n5 = 30;
        Integer n6 = 128;
        Integer n7 = 128;
        System.out.println(n1 == n2);        //         false
        System.out.println(n1.equals(n2));   //         true
        System.out.println(n1 == n3);        //         true
        System.out.println(n1.equals(n3));   //         true
        System.out.println(n1 == n4);        //         false
        System.out.println(n4 == n5);        //         true
        System.out.println(n6 == n7);        //         false
    }

```
